[{"title":"Go语言总结","url":"/2019/05/11/Go语言总结/","content":"\n## 简介\n\n### 诞生原因\n\n为应对多核架构，超大规模分布式计算集群，Web模式导致的前所未有的开发规模和更新速度。\n\n### 特性\n\n- 简单 25个关键字\n\n- 高效 编译强类型，垃圾回收，指针操作\n\n- 生产力 接口\n\n## 一、语言基础\n\n### 变量、常量、以及其他语言差异\n\n赋值方式一\n\n```go\nvar a int = 1\n```\n\n赋值方式二\n\n```go\nvar (\na int = 1\nb =2)\n\na,b = 1,2\n```\n\n赋值方式三\n\n```go\na:=1\nb:=2\n```\n\n常量\n\n```go\nconst(\n  Monday = iota + 1\n  Tuesday\n)\nconst(\n  Open = 1 << iota\n  Close\n)\n```\n\n### 数据类型\n\n- bool\n- string\n- byte //alias for uint8\n- int int8 int16 int32 int64\n- uint uint8 uint16 uint32 uint64 uintptr\n- rune //alias for int32\n- float32 float64\n- complex64 complex128\n\ngo不支持隐式转换，即便是别名也需要显示转换\n\n指针类型不支持指针运算\n\nstring是值类型，期末让你的初始值为空字符串而不是nil\n\n### 运算符\n\n算术运算符\n\n++ -- 只支持后置\n\n用==比较数组，数组维数相等且长度相等可用==比较，每个元素相同为true\n\n### 条件和循环\n\n### 数组和切片\n\n### Map声明、元素访问以及遍历\n\n### Map与工厂模式，在Go语言中实现Set\n\n### 字符串\n\n## 二、语言进阶\n\n### Go语言函数\n\n### 可变参数和defer\n\n### 行为的定义和实现\n\n### Go语言的相关接口\n\n### 扩展和复用\n\n### 不一样的接口类型，一样的多态\n\n### 编写好的错误处理\n\n### panic和recover\n\n### 构建可复用的模块(包)\n\n### 依赖管理\n\n### 协程机制\n\n### 共享内存并发机制\n\n### CSP并发机制\n","tags":["基础"]},{"title":"redis总结","url":"/2019/05/11/redis总结/","tags":["基础 NoSQL"]},{"title":"Docker总结","url":"/2019/05/06/Docker总结/","content":"\n## 一、Docker基础\n\n### Docker架构说明\n\n![Docker架构](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1557248482552&di=7a4687ef725e43a2b17a6c141cfd1fae&imgtype=0&src=http%3A%2F%2Fwww.178linux.com%2Fwp-content%2Fuploads%2F2018%2F08%2F4.png,\"Docker架构\")\n\n>Docker采用Clien/Server架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行再一个HOST上，客户端也可以通过socket和REST API与远程的服务器进行通信。\n\n### 主要组件与概念介绍\n\nDocker包括三个基本概念：\n\n- 镜像(Image)\n- 容器(Container)\n- 仓库(Repository)\n\n#### 镜像\n\ndocker镜像就是一个特殊的文件系统，除了提供容器运行时所需的程序，库，资源，配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷，环境变量，用户等)。镜像不包含任何动态数据，其内容在构建后也不会被改变。\n\n镜像时层层构建的。\n\n#### 容器\n\n镜像与容器的关系就像面向对象编程中，类与实例的关系，镜像时静态的定义，容器时运行时的实体，容器可以被创建启动，停止，暂停，删除\n\n容器的实质是进程，但与直接在宿主机上执行的进程不同，它有自己独立的命名空间。在隔离的环境中运行，就像实在独立于宿主的系统下操作一样。\n\n#### 仓库\n\nDocker Registry是集中的存储和分发镜像的服务，一个Docker Registry中可以包含多个仓库(Repository)；每个仓库可以包含多个标签(Tag)，每个标签对应一个镜像。\n\n通常一个仓库会包含一个软件的不同版本的镜像，标签就是对版本的标识。\n\n可以搭建私有的Docker Registry。\n\n## 二、容器技术\n\n### Cgroup\n\nCgroup用于对进程进行资源利用上的限制或控制，全称为Linux Control Group，是内核的一个功能用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）\n\n### NameSpace\n\n用于隔离内核资源，让一些进程只看到与自己相关的资源，讲进程隔离开来，提供了IPC，NetWork,Mount,PID,User,UTS这些隔离能力，使得不同的命名空间可以有自己独立的共享内存，网络，进程控件，用户，挂载点和文件系统。帮助完成轻量级的虚拟化。\n\n## 三、Docker镜像\n\n### 镜像基本操作\n\n#### 1. 获取镜像\n\n> docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n\n下载时可以看出Docker镜像的分层存储概念\n\n#### 2. 列出镜像\n\n> docker image ls\n\n列表包含，仓库名，标签，镜像ID，创建时间以及所占用空间。\n\n#### 3. 删除本地镜像\n\n> docker image rm [选项] <镜像1> [<镜像2>]\n\n可以使用镜像名或者镜像ID来删除镜像。\n\n可以使用docker image ls 配合删除\n\n例如\n\n> docker image rm $(docker image ls -q redis)\n\n### 私有镜像仓库\n\n### 镜像组织结构\n\n#### base镜像\n\n不依赖其他镜像，其他镜像以之为基础构建。\n\n典型的linux系统由内核空间和用户空间组成,启动时需要两个FS，bootfs+rootfs,base镜像直接用宿主机的kernel，自己提供rootfs。\n\nBase镜像提供最小运行的linux发行版。\n\n#### 镜像的分层结构\n\nDocker支持通过扩展现有镜像，创建新的镜像。\n\n使用DockerFile构建镜像时，一个指令就会构建一层新镜像。\n\n分层的好处时可以资源共享，使用同一种Base镜像就可以只保留一份Base镜像。\n\n如果是共享一份基础镜像，那么当容器修改基础镜像的内容是否会影响其他容器，答案是不会的。修改会被限制在单个容器内。\n\n- 新数据直接放在最上层容器\n- 修改现有数据会从镜像层将数据复制到容器层，修改后的数据直接保存在容器层\n- 如果多个层中有命名，用户只能看到最上层的数据。\n\n### 镜像写时复制\n\n容器启动时将rootfs设为readonly,并在其上挂在一个readwrite的文件系统，这样的一个只读文件系统和一个读写文件系统构成 container的运行目录，所有的改动都在容器层\n\n- 添加文件：在容器中创建文件时，新文件被添加到容器中。\n- 读取文件：在容器中读取某个，Docker会从上往下依次在各镜像层中查找该文件\n- 修改文件：Docker会从上往下依次在各镜像层中查找该文件，一旦找到立即将其复制到容器层，然后修改。\n- 删除文件：在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。\n\n## 四、数据共享与持久化\n\n### 挂载数据卷\n\n使用--mount参数，-v或者--volume\n\n查看所有数据卷\n> docker volume ls\n\n查看数据卷详情\n>docker inspect my-vol\n\nrun容器时加载数据卷\n\n--mount source=my-vol,target=/webapp\n\n删除数据卷\n>docker volume rm my-vol\n\n删除无主数据卷\n>docker volume prune\n\n选择-v还是--mount，推荐--mount,挂在宿主机目录作为数据卷\n> --mount type=bind,source=/src/webapp,target=/opt/webapp,readonly\n\n### 创建数据卷\n\n> docker volume create my-vol\n\n### 数据卷备份与迁移\n\n### 数据卷插件\n\n## 五、Docker网络\n\n### Docker网络模式\n\n- host模式：使用 --net=host 指定。\n\n- none模式：使用 --net=none 指定。\n\n- bridge模式：使用 --net=bridge 指定，默认设置。\n\n- container模式：使用 --net=container:NAME_or_ID 指定。\n\n### 跨主机多子网通信\n\n## 六、Docker最佳实践\n\n### 常用容器命令\n\n### 使用Dockerfile构建镜像\n\n可以通过Dockerfile,利用指令将每一层修改，安装，构建，操作写成脚本。\n\n#### 指令\n\n##### FROM 指定基础镜像\n\n以scratch为基础镜像的，意味着不使用任何镜像作为基础。\n\n##### RNN指令  用于执行命令\n\n两种格式：\n\n> shell格式: RUN <命令>\n\n```shell\nRUN echo 'Hello'\n```\n\n> exec格式: RUN[\"可执行文件\",\"参数1\",\"参数2\"] 这样更像函数调用\n\nDocker的每一个指令就会创建一层镜像，因为UnionFS层数是有限制的，所以RUN 执行的命令可以用\\结尾，并使用&&连接。\n\n##### COPY 复制文件\n\n- COPY <源路径>...<目标路径>\n\n- COPY [\"<源路径1>\",\"<目标路径>\"]\n\n复制时源路径以build时的上下文目录路径为参考，使用相对路径。目标路径时容器内的绝对路径也可以相对于工作目录的相对路径，工作目录由WORKDIR指定。\n\n##### ADD更高级的复制文件\n\n自动解压文件，尽量使用COPY，需要解压文件时使用ADD\n\n##### CMD容器启动命令\n\n指定默认容器主进程的启动命令，\n\n第一种\n> shell格式: CMD <命令>\n\n第二种\n> exec格式: CMD[\"可执行文件\", \"参数1\"...]\n\n第三种\n> CMD[\"参数1\",\"参数2\"...] 在指定了ENTRYPOINT指令后,用CMD指定参数。\n\n##### ENTRYPOINT 入口点\n\n指定容器启动时参数和命令，运行时需要--entrypoint指定。\n\n指定了ENTRYPOINT后，CMD的含义就会被改变，会被传给ENTRYPOINT\n\n> <ENTRYPOINT> <CMD>\n\n适用场景：\n\n- 让镜像像命令一样使用\n- 应用运行前的准备工作\n\n\n##### ENV 设置环境变量\n\n指定环境变量\n\n两种格式：\n\n第一种\n> ENV key=value\n\n第二种\n> ENV key value\n\n##### ARG 构建参数\n\n##### VOLUME 定义匿名卷\n\n##### EXPOSE 暴露端口\n\n##### WORKDIR 指定工作目录\n\n##### USER 指定当前用户\n\n##### HEALTHCHECK 健康检查\n\n##### ONBUILD\n\n### Docker安全部署实践\n\n### Docker运维实践\n","tags":["基础"]},{"title":"JavaScript总结","url":"/2019/04/20/JavaScript总结/","content":"\n## 一、对象\n\n### 基础知识\n\n存储键值映射，可通过{}和其中的一些可选属性来创建。\n\n```js\nlet user = new Object();\nlet user = {};\n```\n\n#### 方括号\n\n除了可以用user.name来获取对象属性，还可以使用user['name']来获取，因为在多词属性时，不可以用类似user.like birds这种语法来获取。还可以用以下方式获取。\n\n```js\nlet key = \"like birds\";\nuser[key] = \"鸭子\";\n```\n\n在对象字面量属性中使用[]，为计算属性，例：\n\n```js\nlet fruit = prompt(\"Which fruit to buy?\", \"apple\");\n\nlet bag = {\n  [fruit]: 5, // 属性名从 fruit 变量中计算\n};\n\nalert( bag.apple ); // 5 如果 fruit=\"apple\"\n```\n\n本质上与以下代码相同:\n\n```js\net fruit = prompt(\"Which fruit to buy?\", \"apple\");\nlet bag = {};\n\n// 从 fruit 变量中获取值\nbag[fruit] = 5;\n```\n\n#### 属性值简写\n\n实际应用中常常将存在的变量当作属性名。\n例如：\n\n```js\nfunction makeUser(name, age) {\n  return {\n    name: name,\n    age: age\n    // 其他的属性\n  };\n}\n\nlet user = makeUser(\"John\", 30);\nalert(user.name); // John\n\n//可简写为\nfunction makeUser(name, age) {\n  return {\n    name, // 与 name: name 相同\n    age   // 与 age: age 相同\n    // ...\n  };\n}\n```\n\n#### 存在值检查\n\n对象可以访问任何属性，如果该属性名没有值，或者不存在，也不会有错误，而是返回undefined。\n\n所以判断属性是否存在时可将获得的值与undefined比较。也可以使用一个特别的操作符\"in\"来检查是否属性存在。\n\n语法为：\n\n```js\n\"key\" in object\n```\n\n#### for in循环\n\n在遍历对象属性时可以使用for in\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30,\n  isAdmin: true\n};\n\nfor(let key in user) {\n  // keys\n  alert( key );  // name, age, isAdmin\n  // 属性键的值\n  alert( user[key] ); // John, 30, true\n}\n```\n\n#### 引用复制\n\n原始类型：字符串，数字，布尔类型是整个赋值的，而对象是引用赋值的，变量将指向同一个地址，他们相等，如果两个引用指向地址不同即便值一样也是不相等的。\n\n例如：\n\n```js\nlet user1 = {};\nlet user2 = user1;\nalert(user1==user2) //true\nlet user2 ={}\nalert(user1==user2) //false\n```\n\nconst修饰的对象中的属性是可变的。\n\n#### 比较引用\n\n等号==与严格等号===对于对象来说是没差别的，当两个引用指向同一个对象的时候他们相等。\n\n#### 赋值和合并\n\n那如何实现对象的深拷贝，可以创建新的对象，通过for in遍历要被复制的对象并赋值给新对象。\n\n也可以使用Object.assign实现\n\n```js\nObject.assign(dest[, src1, src2, src3...])\n```\n\n- 参数 dest 和 src1, ..., srcN（可以有很多个）是对象。\n- 这个方法复制了 src1, ..., srcN 的所有对象到 dest。换句话说，从第二个参数开始，所有对象的属性都复制给了第一个参数对象，然后返回 dest。\n\n该方法进行拷贝：\n\n```js\nlet user = {\n  name: '李白'\n};\n\nlet clone = Object.assign({}, user);\n```\n\n改方法在对象中嵌套了对象时会出现问题，无法深拷贝被嵌套的对象，所以我们深拷贝时可以使用js的库lodash的方法_.cloneDeep(obj)\n\n### Symbol类型\n\n对象的key只能时String或者Symbol类型，String类型比较常见。\n\n#### Symbol\n\nSymbol值表示唯一的标识符。\n\n可以使用Symbol()创建这种类型的值。\n\n例如：\n\n```js\nlet id = Symbol();\n```\n\n为了便于调试，可以给Symbol一个描述。\n\n```js\nlet id = Symbol('id');\n```\n\n描述相同的Symbol值是不一样的，且Symbol转成字符串时需要调用toString方法\n\n#### 隐藏属性\n\nSymbol 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能偶尔访问或重写这些属性。因为用Symbol作为键，在访问时必须用该Symbol去访问。\n\n如果想在字面量中使用Symbol则需要[]\n\nfor in循环会跳过Symbol，Object.assign则不会。\n\n#### 全局Symbol\n\n每一个新建的Symbol都是不同的，所以我们如果想要相同名字的Symbol一致就必须用到全局Symbol注册表，在其中创建Symbol并且在之后可以通过它得到相同名字的Symbol。\n\n创建和读取都用Symbol.for(key)\n\n#### Symbol.keyFor\n\nSymbol.for(key)的一个反向调用，根据一个 全局Symbol获取它的名称。\n\n#### 系统Symbol\n\njs内部存在许多系统Symbol\n\n如：\n\n- Symbol.hasInstance\n- Symbol.isConcatSpreadable\n- Symbol.iterator\n- Symbol.toPrimitive\n\n等\n\n### 对象原始值转换\n\n### 垃圾回收\n\njs的内存管理是自动的，所有我们创建的原始值，对象，函数等都是占用内存的。\n\njs的内存管理概念为可达性，与Java的垃圾回收在一定程度上具有相似性。\n\n将一些值作为根，从根出发，不可以通过引用到达的值将会被垃圾回收，在js引擎中有一个垃圾回收器在后台自动执行，监控所有对象的状态，并删除不可达对象。\n\n### 对象方法与“this”\n\n### 构造函数和操作符\"new\"\n\n## 二、数据类型\n\n## 三、函数\n\n## 四、面向对象\n\n## 五、错误处理\n\n## 六、Document\n\n## 七、事件简介\n\n## 八、事件细节\n\n## 九、表单，控件\n\n## 十、动画\n\n## 十一、框架和窗口\n\n## 十二、正则\n\n## 十三、Promise，async/await\n\n## 十四、网络请求：AJAX和COMET","tags":["基础"]},{"title":"python总结","url":"/2019/04/20/python总结/","content":"\n## 函数式编程：匿名函数、高阶函数、装饰器\n\n### 匿名函数\n\n### 高阶函数\n\n#### 1. 变量可以指向函数\n\n例：\n\n```python\na = -12\nb = abs\nprint(b)\n# 答案为 <built-in function abs>\nprint(b(a))\n# 答案为 12\n```\n\n#### 2. 可传入函数\n\n例：\n\n```python\ndef add(x, y, f):\n    return f(x)+f(y)\nc = add(-5,-8,abs)\nprint(c)\n# 答案为 13\n```\n\n#### 3. 内建map/reduce函数\n\nmap接受两个参数，一个是function,另一个是Iterable，map将function作用于Iterable中的每个元素，返回新的Iterable。\n例：用map将list中的每个元素都平方\n\n```python\ndef fun(x):\n    return x*x\n\nlist1 = [1,2,3,4,5]\nlist2 = map(fun, list1)\nprint(list(list2))\n```\n\nreduce也是接受两个参数，一个是function,另一个是Iterable，reduce将function累积作用于Iterable\n例1：就像这样\n\n```python\ndef fun(x):\n    return x*x\nreduce(fun, [1,2,3,4])\n#计算过程为\n#fun(1,2)\n#fun(fun(1，2)，3)\n#fun(fun(fun(1,2),3),4)\n```\n\n例2：list求和\n\n```python\nfrom functools import reduce\ndef fun(a,b):\n    return a+b\n\nc=reduce(fun, [1,2,3,4,5])\nprint(c)\n```\n\n#### 4. 内建filter函数\nreduce也是接受两个参数，一个是function,另一个是Iterable，filter将function作用于每个Iterable中的元素，更具返回值的true和false进行过滤\n\n```python\ndef is_odd(x):\n    return x%2==1\n\nlist(filter(is_odd, [1,2,3,4,5,6,7]))\n```\n\n#### 5. 内建sorted函数\n\n接受参数Iterable进行排序，可以在接受一个key实现自定义排序\n\n例:根据绝对值排序\n\n```python\nsorted([11,-23,10,-54,-10,9],key=abs)\n```\n\n#### 6. 返回函数，闭包\n\n\n\n#### 7. *args与**kw\n\n*args 非关键字参数，元组\n\n**kw 关键字参数，字典\n\n### 装饰器\n\n## 一切皆对象\n\n## 魔法函数\n\n## 类与对象\n\n## 自定义序列类\n\n## python的set和dict\n\n## 对象引用，可变性郁垃圾回收\n\n## 元类编程\n\n## 迭代器与生成器\n\n## socket编程\n\n## 多线程，多进程和线程池编程\n\n## 协程与异步io\n\n## asyncio并发编程","tags":["基础"],"categories":["python"]},{"title":"Java工程师面试之Java基础","url":"/2019/02/27/Java工程师面试之Java基础/","content":"\n### Java基础语法\n\n1. 简述Java8种基础类型的大小和他们的封装类，以及他们的初始化默认值。\n2. int和Integer的区别是什么，基础类型和包装类型的区别是什么\n3. char型变量能否存储一个中文汉字\n4. 怎样把byte转为String\n5. 如何把数值型字符转为数字\n6. 能否将int强制转换为byte类型变量？如果该值大于byte类型的范围会怎样\n7. 能否在不强制转换的情况下将一个都变了值赋值给long类型\n8. 类型的向下转型是什么\n9. 如何判断数组是null还是为空\n10. 如何判断数组是否有序\n11. 数组的length与 string的length()\n12. Object类种有哪些方法\n13. final，finalize，finally区别\n14. &操作符和&&操作符有什么区别?\n15. a = a + b 与 a += b 的区别？\n16. 3*0.1 == 0.3 将会返回什么？true 还是 false？\n17. loat f=3.4; 是否正确？\n18. short s1 = 1; s1 = s1 + 1;有什么错?\n19. switch 语句中的表达式可以是什么类型数据\n20. while 循环和 do 循环有什么不同\n21. static class 与 non static class的区别\n22. static 关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法\n23. 静态类型有什么特点\n24. main() 方法为什么必须是静态的？能不能声明 main() 方法为非静态\n25. 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用\n26. 静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机呢\n27. 成员方法是否可以访问静态变量？为什么静态方法不能访问成员变量\n28. volatile 修饰符有过什么实践\n29. volatile 变量是什么？volatile 变量和 atomic 变量有什么不同\n30. volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗\n31. 能创建 volatile 数组吗？\n32. transient变量有什么特点\n33. super什么时候使用\n34. public static void 写成 static public void会怎样\n35. 说明一下public static void main(String args[])这段声明里每个关键字的作用\n36. 请说出作用域public, private, protected, 以及不写时的区别\n37. sizeof 是Java 的关键字吗\n38. 能否在运行时向 static final 类型的赋值\n39. inal 与 static 关键字可以用于哪里？它们的作用是什么\n\n### Java面向对象\n1. 面向对象的特征是什么\n2. 重载与重写的区别\n3. 抽象类和接口的区别\n4. UML类图\n5. 静态块与构造块与构造函数执行顺序\n6. 内部类有几种，可否包含外部类成员，为什么要引入内部类\n7. 枚举可以继承，实现接口么\n8. 如何实现对象的克隆\n9. 深考被和浅拷贝的区别\n10. 写clone方法通常都有的一行方法是什么\n11. 深拷贝与浅拷贝如何实现激活机制\n12. Comparator与Compatatable的作用和区别\n13. 在比较对象时==与equals的区别\n14. 重写一个对象的equals运算有何区别\n15. 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对\n16. 什么时不可变对象\n17. 如何构建不可变的类结构\n18. 能否创建一个包含可变对象的不可变对象\n19. 如何对对象进行排序\n20. 构造器是否可以被重写\n21. 方法能否既是static又是synchronizeed\n22. abstact的method是否课同时是static，是否同时是native，是否可同时是synchronized\n23. 当对象作为参数传递到一个方法后，值传递还是引用传递\n24. 能否重载main方法\n25. main方法被声明为private会怎么样\n26. 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递\n27. 接口是什么\n28. 为什么用接口，接口的优点\n29. 匿名内部类是否可以继承其它类？是否可以实现接口\n30. 抽象类中是否可以有main方法\n31. 抽象类中是否可以实现接口\n32. 抽象类是否可以继承具体类\n\n### Java常见工具类\n1. String有哪些函数\n2. StingBuffer，StringBuilder，String的区别\n4. Java常用的包有哪些\n5. Calendar Class的用途\n6. 如何在Java中获取日历类的实例\n7. 日历类中的常用方法\n8. 如何格式化日期对象\n10. locale类是什么\n11. Math.round()什么作用？Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？\n12. XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？DOM 和 SAX 解析器有什么不同？\n13. 用 jdom 解析 xml 文件时如何解决中文问题？如何解析\n\n### Java异常处理\n1. 异常体系结构\n2. 举出5个RuntimeException\n3. 自定义异常\n4. try-catch-finally中的return\n6. throw与throws的区别\n\n### Java集合框架\n\nArrayList\nLinkedList\nVector\nHashMap\nLinkedHashMap\nTreeMap\nHashSet\nLinkedHashSet\nTreeSet\n\n\n### Java反射\n1. 反射的用途及其实现\n2. 反射机制的优缺点\n3. 如何通过反射获得对象的私有字段值\n4. 如何通过反射调用对象的方法\n5. 反射创建类实例的三种方式\n### Java注解\n1. 自定义注解的场景及其实现\n\n### 泛型\n1. 泛型解决哪些问题\n2. 泛型的特点\n\n### 序列化\n1. 什么是序列化\n2. Serializable与Externalizable的区别\n3. transient关键字\n\n### IO\n1. Java中有几种类型的流\n2. JDK为每种类型的流提供了一些抽象类以供继承，分别是哪些类\n","tags":["基础"],"categories":["Java"]}]